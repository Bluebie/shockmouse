// Generated by CoffeeScript 1.8.0
var Color, DS4Gamepad, DS4TouchEvent, events, hid, isBluetoothHID, isDS4HID, isUSBHID, tickEmit, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('../node_modules/ds4/node_modules/lodash');

hid = require('../node_modules/ds4/node_modules/node-hid');

Color = require('color');

events = require('events');

isDS4HID = function(descriptor) {
  return descriptor.vendorId === 1356 && descriptor.productId === 1476;
};

isBluetoothHID = function(descriptor) {
  return descriptor.path.match(/^Bluetooth/);
};

isUSBHID = function(descriptor) {
  return descriptor.path.match(/^USB/);
};

DS4TouchEvent = (function(_super) {
  __extends(DS4TouchEvent, _super);

  function DS4TouchEvent() {
    this.created = new Date;
    this.delta = {
      x: 0,
      y: 0
    };
  }

  return DS4TouchEvent;

})(events.EventEmitter);

tickEmit = function(target, event, arg) {
  return function() {
    return target.emit(event, arg);
  };
};

DS4Gamepad = (function(_super) {
  __extends(DS4Gamepad, _super);

  function DS4Gamepad(device_descriptor) {
    this.hid = new hid.HID(device_descriptor.path);
    console.log("got hid device for controlle");
    this.wireless = !!isBluetoothHID(device_descriptor);
    if (this.wireless) {
      this.hid.getFeatureReport(0x04, 66);
    }
    this.report = {};
    this.timestamp = new Date;
    this.trackpad = {
      touches: []
    };
    this._previous_report = {};
    this._touch_obj_cache = [];
    this._config = {
      led: '#000005',
      blink: false,
      rumble: 0
    };
    this.hid.on('data', (function(_this) {
      return function(buf) {
        var data;
        data = _this._parse_report_data(buf.slice(_this.wireless ? 2 : 0));
        return _this._receive_report(data);
      };
    })(this));
  }

  DS4Gamepad.prototype.set = function(changes) {
    var blinkmode, color, i, key, offset, pkt, prep, rumble, setting, value, _i, _ref, _ref1, _ref2;
    for (setting in changes) {
      value = changes[setting];
      if (this._config[setting] == null) {
        throw new Error("Unknown setting " + setting);
      }
    }
    for (key in changes) {
      value = changes[key];
      this._config[key] = value;
    }
    if (changes.rumble != null) {
      this._config.rumble_coarse = this._config.rumble_fine = changes.rumble;
    }
    if (this.wireless) {
      pkt = new Array(77);
      pkt[0] = 0x11;
      pkt[1] = 128;
      pkt[3] = 255;
      offset = 3;
    } else {
      pkt = new Array(31);
      pkt[0] = 0x05;
      pkt[1] = 255;
      offset = 1;
    }
    prep = function(val) {
      return Math.max(0, Math.min(Math.round(val * 255), 255));
    };
    color = Color(this._config.led);
    blinkmode = (function() {
      if (typeof this._config.blink === 'object') {
        return this._config.blink;
      } else if (this._config.blink === true) {
        return {
          on: 0.25,
          off: 0.5
        };
      } else if (this._config.blink === false) {
        return {
          on: 0,
          off: 0
        };
      } else {
        throw new Error("Blink value invalid");
      }
    }).call(this);
    rumble = typeof this._config.rumble === 'object' ? this._config.rumble : {
      fine: this._config.rumble,
      coarse: this._config.rumble
    };
    if (blinkmode.on > 2.55 || blinkmode.off > 2.55) {
      throw new Error("Blink durations cannot exceed 2.55 seconds");
    }
    if (!(typeof rumble.coarse === 'number' && (0 <= (_ref = rumble.coarse) && _ref <= 1))) {
      throw new Error("Rumble values must be numbers between 0.0 and 1.0");
    }
    if (!(typeof rumble.fine === 'number' && (0 <= (_ref1 = rumble.fine) && _ref1 <= 1))) {
      throw new Error("Rumble values must be numbers between 0.0 and 1.0");
    }
    pkt[offset + 3] = prep(rumble.fine);
    pkt[offset + 4] = prep(rumble.coarse);
    pkt[offset + 5] = color.red();
    pkt[offset + 6] = color.green();
    pkt[offset + 7] = color.blue();
    pkt[offset + 8] = prep(blinkmode.on / 2.55);
    pkt[offset + 9] = prep(blinkmode.off / 2.55);
    for (i = _i = 0, _ref2 = pkt.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
      if (pkt[i] == null) {
        pkt[i] = 0;
      }
    }
    return this.hid.write(pkt);
  };

  DS4Gamepad.prototype._receive_report = function(data) {
    var changes, idx, key, makeTouchObj, new_touch, old_touch, touch, value, _base, _i, _len, _name, _ref, _ref1;
    this.report = data;
    this.emit('report', data);
    this.trackpad.touches = [];
    makeTouchObj = function(info, idx) {
      return {
        x: info["trackPadTouch" + idx + "X"],
        y: info["trackPadTouch" + idx + "Y"],
        active: info["trackPadTouch" + idx + "Active"],
        id: info["trackPadTouch" + idx + "Id"]
      };
    };
    _ref = [0, 1];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      idx = _ref[_i];
      old_touch = makeTouchObj(this._previous_report, idx);
      new_touch = makeTouchObj(data, idx);
      (_base = this._touch_obj_cache)[_name = new_touch.id] || (_base[_name] = new DS4TouchEvent);
      touch = this._touch_obj_cache[new_touch.id];
      for (key in new_touch) {
        value = new_touch[key];
        touch[key] = value;
      }
      touch.delta.x = new_touch.x - old_touch.x;
      touch.delta.y = new_touch.y - old_touch.y;
      if (old_touch.id !== new_touch.id && new_touch.active) {
        process.nextTick(tickEmit(this, 'touchstart', touch));
      }
      if (old_touch.active && !new_touch.active) {
        this._touch_obj_cache[touch.id] = null;
        process.nextTick(tickEmit(this, 'touchend', touch));
        process.nextTick(tickEmit(touch, 'touchend', touch));
      }
      if ((old_touch.x !== new_touch.x || old_touch.y !== new_touch.y) && old_touch.active && new_touch.active) {
        process.nextTick(tickEmit(this, 'touchmove', touch));
        process.nextTick(tickEmit(touch, 'touchmove', touch));
      }
      if (touch.active) {
        this.trackpad.touches.push(touch);
      }
    }
    changes = {};
    _ref1 = this.report;
    for (key in _ref1) {
      value = _ref1[key];
      if (value === true && this._previous_report[key] === false) {
        changes[key] = value;
        process.nextTick(tickEmit(this, 'keydown', key));
        process.nextTick(tickEmit(this, "" + key));
      }
      if (value === false && this._previous_report[key] === true) {
        changes[key] = value;
        process.nextTick(tickEmit(this, 'keyup', key));
        process.nextTick(tickEmit(this, "" + key + "Release"));
      }
      if (key !== 'timestamp' && typeof value !== 'boolean' && JSON.stringify(value) !== JSON.stringify(this._previous_report[key])) {
        changes[key] = value;
        process.nextTick(tickEmit(this, "" + key + "Change", value));
      }
    }
    if (((function() {
      var _results;
      _results = [];
      for (key in changes) {
        _results.push(key);
      }
      return _results;
    })()).length !== 0) {
      this.emit('change', changes);
    }
    return this._previous_report = data;
  };

  DS4Gamepad.prototype._parse_report_data = function(buf) {
    return {
      leftAnalog: {
        x: buf[1] / 127.5 - 1,
        y: buf[2] / 127.5 - 1
      },
      rightAnalog: {
        x: buf[3] / 127.5 - 1,
        y: buf[4] / 127.5 - 1
      },
      l2Analog: buf[8] / 255,
      r2Analog: buf[9] / 255,
      dPadUp: buf[5] === 0 || buf[5] === 1 || buf[5] === 7,
      dPadRight: buf[5] === 1 || buf[5] === 2 || buf[5] === 3,
      dPadDown: buf[5] === 3 || buf[5] === 4 || buf[5] === 5,
      dPadLeft: buf[5] === 5 || buf[5] === 6 || buf[5] === 7,
      cross: (buf[5] & 32) !== 0,
      circle: (buf[5] & 64) !== 0,
      square: (buf[5] & 16) !== 0,
      triangle: (buf[5] & 128) !== 0,
      l1: (buf[6] & 0x01) !== 0,
      l2: (buf[6] & 0x04) !== 0,
      r1: (buf[6] & 0x02) !== 0,
      r2: (buf[6] & 0x08) !== 0,
      l3: (buf[6] & 0x40) !== 0,
      r3: (buf[6] & 0x80) !== 0,
      share: (buf[6] & 0x10) !== 0,
      options: (buf[6] & 0x20) !== 0,
      trackPadButton: (buf[7] & 2) !== 0,
      psButton: (buf[7] & 1) !== 0,
      motionY: buf.readInt16LE(13),
      motionX: -buf.readInt16LE(15),
      motionZ: -buf.readInt16LE(17),
      orientationRoll: -buf.readInt16LE(19),
      orientationYaw: buf.readInt16LE(21),
      orientationPitch: buf.readInt16LE(23),
      trackPadTouch0Id: buf[35] & 0x7f,
      trackPadTouch0Active: (buf[35] >> 7) === 0,
      trackPadTouch0X: ((buf[37] & 0x0f) << 8) | buf[36],
      trackPadTouch0Y: buf[38] << 4 | ((buf[37] & 0xf0) >> 4),
      trackPadTouch1Id: buf[39] & 0x7f,
      trackPadTouch1Active: (buf[39] >> 7) === 0,
      trackPadTouch1X: ((buf[41] & 0x0f) << 8) | buf[40],
      trackPadTouch1Y: buf[42] << 4 | ((buf[41] & 0xf0) >> 4),
      batteryLevel: buf[12]
    };
  };

  return DS4Gamepad;

})(events.EventEmitter);

DS4Gamepad.devices = function() {
  return hid.devices().filter(isDS4HID);
};

exports.Gamepad = DS4Gamepad;

//# sourceMappingURL=sony_controller.js.map
