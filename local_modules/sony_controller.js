// Generated by CoffeeScript 1.8.0
var DS4Gamepad, DS4TouchEvent, ds4, events, hid, isBluetoothHID, isDS4HID, isUSBHID, tickEmit, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('../node_modules/ds4/node_modules/lodash');

hid = require('../node_modules/ds4/node_modules/node-hid');

ds4 = require('../node_modules/ds4');

events = require('events');

isDS4HID = function(descriptor) {
  return descriptor.vendorId === 1356 && descriptor.productId === 1476;
};

isBluetoothHID = function(descriptor) {
  return descriptor.path.match(/^Bluetooth/);
};

isUSBHID = function(descriptor) {
  return descriptor.path.match(/^USB/);
};

DS4TouchEvent = (function(_super) {
  __extends(DS4TouchEvent, _super);

  function DS4TouchEvent() {
    this.created = new Date;
    this.delta = {
      x: 0,
      y: 0
    };
  }

  return DS4TouchEvent;

})(events.EventEmitter);

tickEmit = function(target, event, arg) {
  return function() {
    return target.emit(event, arg);
  };
};

DS4Gamepad = (function(_super) {
  __extends(DS4Gamepad, _super);

  function DS4Gamepad(device_descriptor) {
    this.hid = new hid.HID(device_descriptor.path);
    console.log("got hid device for controlle");
    this.wireless = !!isBluetoothHID(device_descriptor);
    if (this.wireless) {
      this.hid.getFeatureReport(0x04, 66);
    }
    this.report = {};
    this.timestamp = new Date;
    this.trackpad = {
      touches: []
    };
    this._previous_report = {};
    this._touch_obj_cache = [];
    this._config = {
      red: 0.25,
      green: 0.25,
      blue: 0.25,
      small_rumble: 0,
      big_rumble: 0,
      flash_on_duration: 0.0,
      flash_off_duration: 0.0
    };
    this.hid.on('data', (function(_this) {
      return function(buf) {
        var data;
        data = ds4.parseDS4HIDData(buf.slice(_this.wireless ? 2 : 0));
        return _this._receive_report(data);
      };
    })(this));
  }

  DS4Gamepad.prototype.set = function(changes) {
    var i, key, offset, pkt, prep, value, _i, _ref;
    for (key in changes) {
      value = changes[key];
      this._config[key] = value;
    }
    if (this.wireless) {
      pkt = new Array(77);
      pkt[0] = 0x11;
      pkt[1] = 128;
      pkt[3] = 255;
      offset = 3;
    } else {
      pkt = new Array(31);
      pkt[0] = 0x05;
      pkt[1] = 255;
      offset = 1;
    }
    prep = function(val) {
      return Math.max(0, Math.min(Math.round(val * 255), 255));
    };
    pkt[offset + 3] = prep(this._config.small_rumble);
    pkt[offset + 4] = prep(this._config.big_rumble);
    pkt[offset + 5] = prep(this._config.red);
    pkt[offset + 6] = prep(this._config.green);
    pkt[offset + 7] = prep(this._config.blue);
    pkt[offset + 8] = prep(this._config.flash_on_duration / 2.55);
    pkt[offset + 9] = prep(this._config.flash_off_duration / 2.55);
    for (i = _i = 0, _ref = pkt.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (pkt[i] == null) {
        pkt[i] = 0;
      }
    }
    return this.hid.write(pkt);
  };

  DS4Gamepad.prototype._receive_report = function(data) {
    var idx, key, makeTouchObj, new_touch, old_touch, touch, value, _base, _i, _len, _name, _ref, _ref1;
    this.report = data;
    this.emit('report', data);
    this.trackpad.touches = [];
    makeTouchObj = function(info, idx) {
      return {
        x: info["trackPadTouch" + idx + "X"],
        y: info["trackPadTouch" + idx + "Y"],
        active: info["trackPadTouch" + idx + "Active"],
        id: info["trackPadTouch" + idx + "Id"]
      };
    };
    _ref = [0, 1];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      idx = _ref[_i];
      old_touch = makeTouchObj(this._previous_report, idx);
      new_touch = makeTouchObj(data, idx);
      (_base = this._touch_obj_cache)[_name = new_touch.id] || (_base[_name] = new DS4TouchEvent);
      touch = this._touch_obj_cache[new_touch.id];
      for (key in new_touch) {
        value = new_touch[key];
        touch[key] = value;
      }
      touch.delta.x = new_touch.x - old_touch.x;
      touch.delta.y = new_touch.y - old_touch.y;
      if (old_touch.id !== new_touch.id && new_touch.active) {
        process.nextTick(tickEmit(this, 'touchstart', touch));
      }
      if (old_touch.active && !new_touch.active) {
        this._touch_obj_cache[touch.id] = null;
        process.nextTick(tickEmit(this, 'touchend', touch));
        process.nextTick(tickEmit(touch, 'touchend', touch));
      }
      if ((old_touch.x !== new_touch.x || old_touch.y !== new_touch.y) && old_touch.active && new_touch.active) {
        process.nextTick(tickEmit(this, 'touchmove', touch));
        process.nextTick(tickEmit(touch, 'touchmove', touch));
      }
      if (touch.active) {
        this.trackpad.touches.push(touch);
      }
    }
    _ref1 = this.report;
    for (key in _ref1) {
      value = _ref1[key];
      if (value === true && this._previous_report[key] === false) {
        process.nextTick(tickEmit(this, 'keydown', key));
        process.nextTick(tickEmit(this, "" + key));
      }
      if (value === false && this._previous_report[key] === true) {
        process.nextTick(tickEmit(this, 'keyup', key));
        process.nextTick(tickEmit(this, "" + key + "Release"));
      }
      if (value !== this._previous_report[key] && typeof value === 'number' && key !== 'timestamp') {
        process.nextTick(tickEmit(this, 'change', key, value));
        process.nextTick(tickEmit(this, "" + key + "Change", value));
      }
    }
    return this._previous_report = data;
  };

  return DS4Gamepad;

})(events.EventEmitter);

DS4Gamepad.devices = function() {
  return hid.devices().filter(isDS4HID);
};

exports.Gamepad = DS4Gamepad;

//# sourceMappingURL=sony_controller.js.map
